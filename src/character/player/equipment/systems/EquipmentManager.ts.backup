/**
 * Equipment Manager
 * Manages equipped items and inventory integration
 */

import { Equipment, EquipmentSlotType, EquipmentCategory, WeaponState } from '../types/EquipmentTypes';
import { AttachmentSystem } from './AttachmentSystem';
import { EquipmentRenderer } from './EquipmentRenderer';
import { EquipmentRegistry } from '../config/EquipmentRegistry';

/**
 * Manages equipped items and inventory integration
 */
export class EquipmentManager {
  private equippedItems: Map<EquipmentSlotType, Equipment> = new Map(); // Stowed items (on back, visible)
  private wieldedSlot: EquipmentSlotType | null = null; // Currently wielded weapon (in hand)
  private attachmentSystem: AttachmentSystem;
  private renderer: EquipmentRenderer;

  constructor(
    attachmentSystem: AttachmentSystem,
    renderer: EquipmentRenderer
  ) {
    this.attachmentSystem = attachmentSystem;
    this.renderer = renderer;
  }

  /**
   * Equip item to slot
   */
  async equip(
    equipment: Equipment,
    targetSlot: EquipmentSlotType
  ): Promise<boolean> {
    // Validate slot compatibility
    if (!this.isCompatible(equipment, targetSlot)) {
      console.error(`[EquipmentManager] Equipment ${equipment.id} not compatible with slot ${targetSlot}`);
      return false;
    }

    // Validate back weapon limit (max 2)
    if (this.isBackWeaponSlot(targetSlot)) {
      const backWeaponsCount = this.getEquippedBackWeaponsCount();
      if (backWeaponsCount >= 2 && !this.equippedItems.has(targetSlot)) {
        console.error('[EquipmentManager] Cannot equip more than 2 back weapons');
        return false;
      }
    }

    // Unequip existing item in slot
    await this.unequip(targetSlot);

    // Load model
    const model = await this.renderer.loadModel(equipment);
    if (!model) {
      console.error(`[EquipmentManager] Failed to load model for ${equipment.id}`);
      return false;
    }

    // Attach to slot
    const attached = this.attachmentSystem.attach(equipment, targetSlot, model);
    if (!attached) {
      console.error(`[EquipmentManager] Failed to attach ${equipment.id} to ${targetSlot}`);
      return false;
    }

    // Store equipped item
    this.equippedItems.set(targetSlot, equipment);

    console.log(`[EquipmentManager] Equipped ${equipment.id} to ${targetSlot}`);
    return true;
  }

  /**
   * Unequip item from slot
   */
  async unequip(slot: EquipmentSlotType): Promise<Equipment | null> {
    const equipment = this.equippedItems.get(slot);
    if (!equipment) return null;

    // Detach visual
    this.attachmentSystem.detach(slot);

    // Remove from equipped items
    this.equippedItems.delete(slot);

    console.log(`[EquipmentManager] Unequipped ${equipment.id} from ${slot}`);
    return equipment;
  }

  /**
   * Check if equipment is compatible with slot
   */
  private isCompatible(
    equipment: Equipment,
    slot: EquipmentSlotType
  ): boolean {
    // Check if equipment declares this slot as compatible
    if ('compatibleSlots' in equipment) {
      return equipment.compatibleSlots.includes(slot);
    }

    // Check slot configuration
    const slotConfig = EquipmentRegistry.getSlotConfig(slot);
    if (!slotConfig) return false;

    // Check category match
    if (slotConfig.category !== equipment.category) return false;

    // Check specific type compatibility
    if ('weaponType' in equipment) {
      return slotConfig.allowedTypes.includes(equipment.weaponType);
    }
    if ('consumableType' in equipment) {
      return slotConfig.allowedTypes.includes(equipment.consumableType);
    }

    return true;
  }

  /**
   * Check if slot is a back weapon slot
   */
  private isBackWeaponSlot(slot: EquipmentSlotType): boolean {
    return slot === EquipmentSlotType.BACK_LEFT || slot === EquipmentSlotType.BACK_RIGHT;
  }

  /**
   * Get count of equipped back weapons
   */
  private getEquippedBackWeaponsCount(): number {
    let count = 0;
    if (this.equippedItems.has(EquipmentSlotType.BACK_LEFT)) count++;
    if (this.equippedItems.has(EquipmentSlotType.BACK_RIGHT)) count++;
    return count;
  }

  /**
   * Get equipment in slot
   */
  getEquipped(slot: EquipmentSlotType): Equipment | null {
    return this.equippedItems.get(slot) || null;
  }

  /**
   * Get all equipped items
   */
  getAllEquipped(): Map<EquipmentSlotType, Equipment> {
    return new Map(this.equippedItems);
  }

  /**
   * Find slots that can hold this equipment
   */
  getCompatibleSlots(equipment: Equipment): EquipmentSlotType[] {
    if ('compatibleSlots' in equipment) {
      return [...equipment.compatibleSlots];
    }
    return [];
  }

  /**
   * Toggle equipment visibility (e.g., stow weapon)
   */
  setSlotVisible(slot: EquipmentSlotType, visible: boolean) {
    this.attachmentSystem.setVisible(slot, visible);
  }

  /**
   * Check if slot is occupied
   */
  isSlotOccupied(slot: EquipmentSlotType): boolean {
    return this.equippedItems.has(slot);
  }

  /**
   * Get first available back weapon slot
   */
  getFirstAvailableBackSlot(): EquipmentSlotType | null {
    if (!this.equippedItems.has(EquipmentSlotType.BACK_LEFT)) {
      return EquipmentSlotType.BACK_LEFT;
    }
    if (!this.equippedItems.has(EquipmentSlotType.BACK_RIGHT)) {
      return EquipmentSlotType.BACK_RIGHT;
    }
    return null;
  }

  /**
   * Get first available thigh slot
   */
  getFirstAvailableThighSlot(): EquipmentSlotType | null {
    if (!this.equippedItems.has(EquipmentSlotType.THIGH_RIGHT)) {
      return EquipmentSlotType.THIGH_RIGHT;
    }
    if (!this.equippedItems.has(EquipmentSlotType.THIGH_LEFT)) {
      return EquipmentSlotType.THIGH_LEFT;
    }
    return null;
  }

  /**
   * Can this equipment be equipped (considering all constraints)?
   */
  canEquip(equipment: Equipment, slot?: EquipmentSlotType): boolean {
    // If no slot specified, check if ANY compatible slot is available
    if (!slot) {
      const compatibleSlots = this.getCompatibleSlots(equipment);
      for (const testSlot of compatibleSlots) {
        if (this.canEquip(equipment, testSlot)) {
          return true;
        }
      }
      return false;
    }

    // Check compatibility
    if (!this.isCompatible(equipment, slot)) {
      return false;
    }

    // Check back weapon limit
    if (this.isBackWeaponSlot(slot)) {
      const backWeaponsCount = this.getEquippedBackWeaponsCount();
      // Can equip if slot is empty OR replacing existing item in same slot
      if (backWeaponsCount >= 2 && !this.equippedItems.has(slot)) {
        return false;
      }
    }

    return true;
  }

  /**
   * Wield a weapon (draw from stowed position to hand)
   * Weapon must already be equipped (stowed) in a slot
   */
  async wield(slot: EquipmentSlotType): Promise<boolean> {
    const equipment = this.equippedItems.get(slot);
    if (!equipment) {
      console.error(`[EquipmentManager] No equipment in slot ${slot} to wield`);
      return false;
    }

    // If already wielding this slot, do nothing
    if (this.wieldedSlot === slot) {
      console.log(`[EquipmentManager] Already wielding ${slot}`);
      return true;
    }

    // If wielding another weapon, stow it first
    if (this.wieldedSlot) {
      await this.stow();
    }

    // Hide the stowed visual (on back)
    this.attachmentSystem.setVisible(slot, false);

    // TODO: In Phase 7, attach to hand bone with animation
    // For now, just track the wielded state
    this.wieldedSlot = slot;

    console.log(`[EquipmentManager] Wielded ${equipment.id} from ${slot}`);
    return true;
  }

  /**
   * Stow the currently wielded weapon (put back to stowed position)
   */
  async stow(): Promise<boolean> {
    if (!this.wieldedSlot) {
      console.log('[EquipmentManager] No weapon to stow');
      return true;
    }

    const slot = this.wieldedSlot;
    const equipment = this.equippedItems.get(slot);

    // Show the stowed visual (on back) again
    this.attachmentSystem.setVisible(slot, true);

    // TODO: In Phase 7, handle hand attachment removal with animation

    this.wieldedSlot = null;

    console.log(`[EquipmentManager] Stowed weapon back to ${slot}`);
    return true;
  }

  /**
   * Get currently wielded weapon slot
   */
  getWieldedSlot(): EquipmentSlotType | null {
    return this.wieldedSlot;
  }

  /**
   * Get currently wielded equipment
   */
  getWieldedEquipment(): Equipment | null {
    if (!this.wieldedSlot) return null;
    return this.equippedItems.get(this.wieldedSlot) || null;
  }

  /**
   * Check if a specific slot is currently wielded
   */
  isWielded(slot: EquipmentSlotType): boolean {
    return this.wieldedSlot === slot;
  }

  /**
   * Get weapon state for a slot
   */
  getWeaponState(slot: EquipmentSlotType): WeaponState {
    if (!this.equippedItems.has(slot)) {
      return WeaponState.IN_INVENTORY;
    }
    if (this.wieldedSlot === slot) {
      return WeaponState.WIELDED;
    }
    return WeaponState.STOWED;
  }
}
